**********************************************************************************
Changes for Robots
**********************************************************************************

HEADER ----------------------------------------------
remove 
#include <drawstuff/drawstuff.h>
#include "simulation.h"

add

#include "primitive.h"
#include "joint.h"

namespace lpzrobots {

Constructor add 
, const OsgHandle& osgHandle

virtual void place(Position pos , Color *c = 0);
->
/** sets the pose of the vehicle
    @params pose desired 4x4 pose matrix
*/
virtual void place(const osg::Matrix& pose);

virtual void draw();
->
/// update the subcomponents
virtual void update();


virtual Object getMainObject() const { return object[0]; }
->
/** the main object of the robot, which is used for position and speed tracking */
virtual Primitive* getMainPrimitive() const { return object[0]; }

virtual void create(Position pos); 
->
/** creates vehicle at desired pose
    @param pose 4x4 pose matrix
*/
virtual void create(const osg::Matrix& pose); 


virtual void draw()
->
/// update all primitives and joints
virtual void update()

Object object[X];
->
Primitive* object[X];

dJointID joint[X]; 
->
Joint* joint[X]; 


dSpaceID vehicle_space;
-> This is for good reason, trust me :-)
dSpaceID parentspace; 

obsolete:
virtual void setTextures(int body, int wheels);

texture variables like bodyTexture ...

CPP  ----------------------------------------------
remove 
#include <drawstuff/drawstuff.h>
#include <ode/ode.h>
#include "simulation.h"

add 
namespace lpzrobots {

}

Constructor:
add parameter
, const OsgHandle& osgHandle
and
:  OdeRobot(odehandle, 
->
:  OdeRobot(odehandle, osgHandle

and code:
parentspace = odeHandle.space;


color.r=2;
color.g=156/255.0;
color.b=0/255.0;
->
this->osgHandle.color = Color(2, 156/255.0, 0, 1.0f);

here is an sample implenation of place (adjust the height)
void Classname::place(const Matrix& pose){
    // the position of the robot is the center of the body (without wheels)
    // to set the vehicle on the ground when the z component of the position is 0
    // width*0.6 is added (without this the wheels and half of the robot will be in the ground)    
    osg::Matrix p2;
    p2 = pose * osg::Matrix::translate(osg::Vec3(0, 0, width*0.6)); 
    create(p2);
    
};

draw() {
drawcode
}
->
update(){
updatecode
}

drawcode moves mainly to create see below
updatecode looks as follows:
    assert(created); // robot must exist
  
    for (int i=0; i<segmentsno; i++) { 
      object[i]->update();
    }
    for (int i=0; i < 4; i++) { 
      joint[i]->update();
    }
    // update sensors like
    irSensorBank.update();  


void Classname::create(Position pos)
->
void Classname::create(const osg::Matrix& pose)
	
// create vehicle space and add it to parentspace
odeHandle.space = dSimpleSpaceCreate (parentspace);

object[0] = new Capsule(width/2, length);
object[0]->init(odeHandle, cmass, osgHandle);    
// rotate and place body (here by 90° around the y-axis)
object[0]->setPose(osg::Matrix::rotate(M_PI/2, 0, 1, 0) * pose);
object[0]->getOSGPrimitive()->setTexture("Images/wood.rgb");

Please note that the transformations are done via
osg::Matrix::rotate and translate
Joints look as follows. Also note that amotor are done via AngularMotorXAxis classes

    for (int i=0; i<(NUM-1); i++) {
      Pos p1(object[i]->getPosition());
      Pos p2(object[i+1]->getPosition());
      joint[i] = new BallJoint(object[i],object[i+1], (p1+p2)/2 );
      joint[i]->init(odeHandle, osgHandle, true, RADIUS/10);
    }


destroy:

    for (int i=0; i<segmentsno; i++){
      if(object[i]) delete object[i];
    }
    for (int i=0; i<2; i++){
      if(joint[i]) delete joint[i];
    }
    for (int i=0; i<2; i++){
      if(bumper[i].bump) delete bumper[i].bump;
      if(bumper[i].transform) delete bumper[i].transform;
    }
    dSpaceDestroy(odeHandle.space);


collisionCallBack:

internal space collisions should go to doInternalStuff() (see hurlingsnake.cpp)

vehicle_space 
->
odeHandle.space

world
->
odeHandle.world

object[X].geom
->
object[X]->getGeom()

contactgroup
->
odeHandle.jointGroup

**********************************************************************************
Changes for Simulations:
**********************************************************************************

First of all use the new Makefile form template_onerobot

A simulation is now a class called Simulation.
You should derive your own one and overload the 
start, end, config ... functions. 
However, there is a compatibility class called CompatSim, which can be  
initialised with the callback functions as before.

Remove 
#include <drawstuff/drawstuff.h>
#include <ode/ode.h>

Replace:

#include "sphere.h"
#include "passivesphere.h"

Add:

using namespace lpzrobots;

class ThisSim : public Simulation {
public:
	

Replace:
//Startfunktion die am Anfang der Simulationsschleife, einmal ausgefuehrt wird
void start(const OdeHandle& odeHandle, GlobalData& global) 
->
/// start() is called at the start and should create all the object (obstacles, agents...).
virtual void start(const OdeHandle& odeHandle, const OsgHandle& osgHandle, GlobalData& global){


The end function is not needed anymore because
the obstactle list and the agent list is cleared by the framework. 
So remove:
void end(GlobalData& global);

In case you want to cleanup something you can define:
/// end() is called at the end and should tidy up
virtual void end(GlobalData& global){
}




//Anfangskameraposition und Punkt auf den die Kamera blickt
float KameraXYZ[3]= {2.1640f,-1.3079f,1.7600f};
float KameraViewXYZ[3] = {125.5000f,-17.0000f,0.0000f};;
dsSetViewpoint ( KameraXYZ , KameraViewXYZ );
->
setCameraHomePos(Pos(2.1640f,-1.3079f,1.7600f), Pos(125.5, -17.0, 0));


Remove:
// this function is called if the user pressed Ctrl-C
void config(GlobalData& global){

dsSetSphereQuality (2); //Qualitaet in der Sphaeren gezeichnet werden


Replace:
dsPrint
-> 
printf
However the Welcome Message can be ommited!

Insert in Contructor of Obstacles and Robots
	, osgHandle


Obstacles have no setGeometry anymore
example:
   Playground* playground = new Playground(odeHandle, osgHandle);
   playground->setGeometry(10.0,0.2,2.5)
->	
   Playground* playground = new Playground(odeHandle, osgHandle, osg::Vec3(10.0, 0.2, 2.5));


in main:
Replace:
  // initialise the simulation and provide the start, end, and config-function
  simulation_init(&start, &end, &config);
  // start the simulation (returns, if the user closes the simulation)
  simulation_start(argc, argv);
  simulation_close();  // tidy up.
  return 0;
->
ThisSim sim;
return sim.run(argc, argv) ? 0 : 1;

oder

CompatSim version:
CompatSim sim(&start, &end, &config);
return sim.run(argc, argv) ? 0 : 1;





